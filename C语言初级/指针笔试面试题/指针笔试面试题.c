//#define _CRT_SECURE_NO_WARNINGS 1
//#include <stdio.h>
//int main()
//{
//	int a[5] = { 1,2,3,4,5 };
//	int* ptr = (int*)(&a + 1);//这里的&a取出的是整个数组的地址，&a+1是跳过这个数组的地址
//	printf("%d %d", *(a+1), *(ptr - 1));//ptr-1指向的是第五个元素的地址   2  5
//	return 0;
//}

//#include <stdio.h>
////假设p的值为0x100000.如下表达式的值分别为多少？
////已知，结构体Test类型的变量大小是20个字节
//struct Test
//{
//	int Num;
//	char* pcName;
//	short sDate;
//	char cha[2];
//	short sBa[4];
//}*p;
//int main()
//{
//	p = (struct Test*)0x100000;
//	printf("%p\n", p);//00100000
//	printf("%p\n", p + 0x1);//0x1就是十六进制的1，也就是1.  p + 0x1就是跳过一个结构体的地址00100014
//	printf("%p\n", (unsigned long)p + 0x1);//p被强制类型转换为整型，00100001
//	printf("%p\n", (unsigned int*)p + 0x1);//p被强制类型转换为int*，00100004
//	return 0;
//}


//#include <stdio.h>
//int main()
//{                                          //           |     1     |     2     |     3     |     4     |
//	int a[4] = { 1,2,3,4 };//内存中的存储模式：小端存储 |01 00 00 00|02 00 00 00|03 00 00 00|04 00 00 00|
//	int* ptr1 = (int*)(&a + 1);//                       |   |       |           |           |           |
//	int* ptr2 = (int*)((int)a + 1);//                       |                                           |
//	printf("%x %x", ptr1[-1], *ptr2);//                    ptr2                                        ptr1
//	return 0;//假设a的地址为0x 00 00 00 05,将a强制类型转换+1后为0x 00 00 00 06，再转为地址后为0x 00 00 00 06
//	         //两个地址差1，也就是差一个字节，所以ptr2里面的内容为0x 00 00 00 02,*ptr2=0x 02 00 00 00 = 2000000
//}

//#include <stdio.h>
//int main()
//{
//	int a[3][2] = { (0,1),(2,3),(4,5) };//(0,1)....逗号表达式 实际上 int a[3][2] = { 1, 2, 3 };
//	int* p;
//	p = a[0];//a[0]是第一行的数组名，代表的是第一行第一个元素的地址,即1的地址
//	printf("%d", p[0]);//p[0]==*(p+0),即1的地址+0解引用还是1
//	return 0;
//}

//#include <stdio.h>
//int main()          
//{
//	int a[5][5];
//	int(*p)[4];
//	p = a;//p的类型int(*)[4]  a的类型int(*)[5]  把第一行的地址放到p里面，虽然放不下，但地址起始位置还是一样的
//	printf("%p %d\n", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);//&p[4][2]==&(*(*(p+4)+2))
//	return 0;
//}
//p+4的地址起始位置如下图显示
//*(p+4)拿到的是：p+4的地址起始位置之后四个字节内容的数组，相当于拿到了数组名，数组名又相当于首元素地址
//*(p+4)+2拿到的是：该数组第三个元素的地址
//*(*(p+4)+2)拿到的是：该数组的第三个元素
//&*(*(p+4)+2)拿到的是：该数组第三个元素的地址 
//两个地址相减 = - 4，第一个以%p打印，以地址形式打印
//-4的补码1111 1111 1111 1111 1111 1111 1111 1100
//打印的是  F    F   F     F    F    F    F    C
// p          p+1           p+2           p+3           p+4  *(p+4)+2
// |           |             |             |             |     |
// |―|―|―|―|―| |―|―|―|―|―| |―|―|―|―|―| |―|―|―|―|―| |―|―|―|―|―| 
// |__|__|__|__|__| |__|__|__|__|__| |__|__|__|__|__| |__|__|__|__|__| |__|__|__|__|__| 
//                                                              |             |
//                                                          &p[4][2]       &a[4][2]
//      a[0]             a[1]             a[2]             a[3]             a[4]     


//#include <stdio.h>
//int main()
//{
//	int a[2][5] = { 1,2,3,4,5,6,7,8,9,10 };
//	int* ptr1 = (int*)(&a + 1);//&a表示整个数组的地址，&a+1表示的是跳过这个数组的地址
//	int* ptr2 = (int*)(*(a + 1));//a表示的是第一行的地址，a+1表示的是第二行的地址，*（a+1）表示的是第二行，即第二行的数组名，即第二行的首元素地址
//	printf("%d %d", *(ptr1 - 1), *(ptr2 - 1));//10   5
//	return 0;
//}


//#include <stdio.h>
//int main()
//{
//	//char* p = "abcdef";//p里面放的是a的地址
//
//	char* a[] = { "work","at","alibaba" };//字符指针数组，该数组有三个元素，每个元素都是各字符串首字符的地址
//	char** pa = a;//a表示的是首元素的地址，即w的地址
//	pa++;//pa++相当于pa+1，跳过一个char*类型的地址，即a的地址
//	printf("%s\n", *pa);//*pa：以a的位置为起始位置打印字符串
//	return 0;
//}


#include <stdio.h>
int main()
{
	char* c[] = { "ENTER","NEW","POINT","FIRST" };
	char** cp[] = { c + 3,c + 2,c + 1,c };
	char*** cpp = cp;
	printf("%s\n", **++cpp);//++cpp之后cpp被改变		POINT
	printf("%s\n", *-- * ++cpp + 3);//++/--cpp后，cpp被改变     ER
	printf("%s\n", *cpp[-2] + 3);//**(cpp-2)+3            ST
	printf("%s\n", cpp[-1][-1] + 1);//*(*(cpp-1)-1)+1     EW
	return 0;
}