// 位段的声明和结构是类似的，但有两个不同：
// 1.位段的成员必须是 int、unsigned int、signed int（有符号整型）、只要是整型就可以或者是char
// 2.位段的成员名后边有一个冒号和一个数字
// 位段的内存分配规则
// 1.位段的成员可以是 int、unsigned int、signed int 或者是char(属于整型家族)类型
// 2.位段的空间上是按照需要以4个字节（int）或者一个字节（char）的方式来开辟的
// 3.位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段

// 位段式的结构体
/*struct A
{
	int _a : 2;//   _a的值只需要2个bit就能存下，下面类似
	int _b : 5;
	int _c : 10;
	int _d : 30;
};*/
// A就是一个位段，那位段A的大小是多少？
// 直接开辟一个4个字节的空间（共32个bit），_a、_b、_c放进去之后只剩15个bit
// 不够存储d,所以重新开辟一个4个字节的空间用来存放d,所以位段A的大小一共是8个字节
/*#include <stdio.h>
int main()
{
	printf("%d\n", sizeof(struct A)); // 位段A的大小为：8个字节
	return 0;
}*/

#include <stdio.h>
struct S
{
	char a : 3;
	char b : 4;
	char c : 5;
	char d : 4;
};
int main()
{
	struct S s = { 0 };
	s.a = 10;
	s.b = 20;
	s.c = 3;
	s.d = 4;
	printf("%d\n", sizeof(s));
	return 0;
}
// 位段的跨平台问题
// 1.int位段被当成有符号数还是无符号数是不确定的
// 2.位段中最大位的数目不能确定。（16位机器最大16,32位机器最大32，写成27，在16位机器会出问题）
// 3.位段中的成员在内存中从左向右分配，还是从右向左分配标准尚未定义
// 4.当一个结构包含两个段位，第二个段位成员比较大，无法容纳与第一个位段剩余的位时，是舍弃剩余的位还是利用，这是不确定的
// 总结：跟结构相比，位段可以达到同样的效果，但是可以很好的节省空间，但是有跨平台的问题存在